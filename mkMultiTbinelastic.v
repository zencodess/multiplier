//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Wed Dec  5 17:57:48 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMultiTbinelastic(CLK,
			  RST_N);
  input  CLK;
  input  RST_N;

  // register cycle
  reg [31 : 0] cycle;
  wire [31 : 0] cycle$D_IN;
  wire cycle$EN;

  // register x
  reg [15 : 0] x;
  wire [15 : 0] x$D_IN;
  wire x$EN;

  // register y
  reg [15 : 0] y;
  wire [15 : 0] y$D_IN;
  wire y$EN;

  // ports of submodule dut
  wire [31 : 0] dut$result;
  wire [15 : 0] dut$start_m1, dut$start_m2;
  wire dut$EN_start, dut$RDY_result;

  // rule scheduling signals
  wire CAN_FIRE_RL_cyclecount,
       CAN_FIRE_RL_rule_tb_1,
       CAN_FIRE_RL_rule_tb_2,
       CAN_FIRE_RL_stop,
       WILL_FIRE_RL_cyclecount,
       WILL_FIRE_RL_rule_tb_1,
       WILL_FIRE_RL_rule_tb_2,
       WILL_FIRE_RL_stop;

  // remaining internal signals
  wire [63 : 0] _0_CONCAT_x_MINUS_1_2_3_MUL_0_CONCAT_y_MINUS_1_4_5___d16;
  wire [15 : 0] x__h425, x__h446;
  wire x_ULT_100___d6;

  // submodule dut
  mkInelasticPipe dut(.CLK(CLK),
		      .RST_N(RST_N),
		      .start_m1(dut$start_m1),
		      .start_m2(dut$start_m2),
		      .EN_start(dut$EN_start),
		      .RDY_start(),
		      .result(dut$result),
		      .RDY_result(dut$RDY_result));

  // rule RL_cyclecount
  assign CAN_FIRE_RL_cyclecount = 1'd1 ;
  assign WILL_FIRE_RL_cyclecount = 1'd1 ;

  // rule RL_rule_tb_2
  assign CAN_FIRE_RL_rule_tb_2 = dut$RDY_result && x_ULT_100___d6 ;
  assign WILL_FIRE_RL_rule_tb_2 = CAN_FIRE_RL_rule_tb_2 ;

  // rule RL_rule_tb_1
  assign CAN_FIRE_RL_rule_tb_1 = x_ULT_100___d6 ;
  assign WILL_FIRE_RL_rule_tb_1 = x_ULT_100___d6 ;

  // rule RL_stop
  assign CAN_FIRE_RL_stop = !x_ULT_100___d6 ;
  assign WILL_FIRE_RL_stop = CAN_FIRE_RL_stop ;

  // register cycle
  assign cycle$D_IN = cycle + 32'd1 ;
  assign cycle$EN = 1'd1 ;

  // register x
  assign x$D_IN = x + 16'd1 ;
  assign x$EN = x_ULT_100___d6 ;

  // register y
  assign y$D_IN = y + 16'd1 ;
  assign y$EN = x_ULT_100___d6 ;

  // submodule dut
  assign dut$start_m1 = x ;
  assign dut$start_m2 = y ;
  assign dut$EN_start = x_ULT_100___d6 ;

  // remaining internal signals
  assign _0_CONCAT_x_MINUS_1_2_3_MUL_0_CONCAT_y_MINUS_1_4_5___d16 =
	     { 16'd0, x__h425 } * { 16'd0, x__h446 } ;
  assign x_ULT_100___d6 = x < 16'd100 ;
  assign x__h425 = x - 16'd1 ;
  assign x__h446 = y - 16'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	x <= `BSV_ASSIGNMENT_DELAY 16'd1;
	y <= `BSV_ASSIGNMENT_DELAY 16'd1;
      end
    else
      begin
        if (cycle$EN) cycle <= `BSV_ASSIGNMENT_DELAY cycle$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycle = 32'hAAAAAAAA;
    x = 16'hAAAA;
    y = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      $display("------Cycle %0d----%d----%d", $signed(cycle), x, y);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2) $display("Rule tb2 fired");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2)
	$display("    Result = %0d Expected = %0d",
		 dut$result,
		 _0_CONCAT_x_MINUS_1_2_3_MUL_0_CONCAT_y_MINUS_1_4_5___d16[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2 &&
	  dut$result !=
	  _0_CONCAT_x_MINUS_1_2_3_MUL_0_CONCAT_y_MINUS_1_4_5___d16[31:0])
	$display("Error");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2) $display("-------------------------------");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_1) $display("Rule tb1 fired");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_1)
	$display("Test Input: x = %0d, y = %0d", x, y);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stop) $display("\t finish");
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_stop) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkMultiTbinelastic

